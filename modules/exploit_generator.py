# modules/exploit_generator.py
from pathlib import Path
import re
from typing import Optional
from .fetch_html import fetch_html
from .html2md import html_to_markdown
from .llm import generate_response
from config import NEXT_URL_TXT, OUTPUT_HTML, OUTPUT_MD, EXPLOIT_PATH, MAXIMUM_URLS, INITPROMPT, RETRYPROMPT, ERRORMSG, OUTPUT_PROMPT

# 如果你使用 Gemini API：會嘗試使用 google.generativeai
# 若未設定 GEMINI_KEY，程式會提醒並不呼叫 API（保守行為）
def extract_code_best_effort(text: str) -> Optional[str]:
    # 優先找 ```ruby code fence
    m = re.findall(r"```ruby\s*(.*?)```", text, re.IGNORECASE | re.DOTALL)
    if m:
        return max(m, key=len).strip()
    # 找任意 code fence
    m_all = re.findall(r"```(?:[^\n]*)\n(.*?)```", text, re.DOTALL)
    if m_all:
        return max(m_all, key=len).strip()
    # fallback：找 MetasploitModule class 開頭
    m = re.search(r"(class\s+MetasploitModule\b.*)", text, re.DOTALL)
    if m:
        return m.group(1).strip()
    return None

def genRb(markdown_content: str, debug: bool = False, FirstTry: bool = True, prompt_index: int = 0, model: str = "gemini-2.0-flash") -> bool:
    """
    呼叫 LLM 生成 Ruby 程式（示意）。你需要設定環境變數 GEMINI_KEY
    若沒有 GEMINI_KEY，會 raise ValueError。
    返回 True 表示需要 retry（原 genRb 用法），False 表示完成或不再 retry。
    """

    prompt = ""
    if FirstTry:
        # 從當前目錄取 InitPrompt.txt（如存在）
        init_prompt_path = INITPROMPT
        if init_prompt_path.exists():
            lines = init_prompt_path.read_text(encoding="utf-8").splitlines()
            # pick 一行（1-based index）
            if prompt_index > 0 and prompt_index <= len(lines):
                prompt = lines[prompt_index - 1]
            else:
                prompt = lines[0] if lines else ""
        else:
            prompt = ""
    else:
        # retry mode: 可從 exploit file 與 errorMsg.txt 組 prompt
        if EXPLOIT_PATH.exists():
            existing_code = EXPLOIT_PATH.read_text(encoding="utf-8")
        else:
            existing_code = ""
        error_msg_path = ERRORMSG
        err = error_msg_path.read_text(encoding="utf-8") if error_msg_path.exists() else ""
        retry_prompt_path = RETRYPROMPT
        retry_text = retry_prompt_path.read_text(encoding="utf-8").splitlines()[prompt_index - 1] if retry_prompt_path.exists() else ""
        prompt = existing_code + "\n Error msg: " + err + "\n" + retry_text

    prompt += "\n\n" + markdown_content

    with OUTPUT_PROMPT.open("w", encoding="utf-8") as f:
        f.write(prompt)
    # 呼叫 model
    ruby_code = generate_response(prompt, model=model, web_search=False)

    # 嘗試解析可能的 next urls（line 開頭為 http...）
    pattern = r'^(https?://[^\s\'"<>)]+(?:\s+https?://[^\s\'"<>)]+)*)'
    match = re.match(pattern, ruby_code)
    if match:
        next_url = match.group(1).split()
        with NEXT_URL_TXT.open("w", encoding="utf-8") as f:
            f.write("\n".join(next_url) + "\n")
        if debug:
            print("Wrote next urls from model response to", NEXT_URL_TXT)

    if debug:
        print("=== Gemini Response ===")
        print(ruby_code)
        print("===================================")

    extracted = extract_code_best_effort(ruby_code)
    EXPLOIT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with EXPLOIT_PATH.open("w", encoding="utf-8") as f:
        if extracted:
            f.write(extracted)
            if debug:
                print(f"[+] Exploit generated and saved to: {EXPLOIT_PATH}")
        else:
            f.write(ruby_code)
            if debug:
                print(f"[!] Could not extract code cleanly, saved raw response to {EXPLOIT_PATH}")
    return False

def exec_genrb_from_main(retry: bool = False, enable_debug: bool = False, prompt_index: int = 1, model: str = "gpt-4.1"):
    """
    將 next_url.txt 裡的 url 抓下 html -> md -> 呼叫 genRb。
    這個函式供 main.py 呼叫（簡單封裝）。
    """
    # 讀 next_url.txt
    if not NEXT_URL_TXT.exists():
        print("No next_url.txt found at", NEXT_URL_TXT)
        return

    urls = [line.strip() for line in NEXT_URL_TXT.read_text(encoding="utf-8").splitlines() if line.strip()]
    if not urls:
        print("No urls in", NEXT_URL_TXT)
        return

    md_accum = ""
    t = 0
    for url in urls:
        if t >= MAXIMUM_URLS:
            break
        if not (url.startswith("http://") or url.startswith("https://")):
            print("Skipping invalid URL:", url)
            continue
        html = fetch_html(url, OUTPUT_HTML, debug=enable_debug)
        if not html:
            print("Skipping URL due to fetch error:", url)
            continue
        md_accum += f"Target url {url}:\n\n" + html_to_markdown(html) + "\n\n"
        t += 1
    
    prompt = "Please take the Markdown document I provide and rewrite it to be more concise while preserving all essential including the code part. Markdown Content: "
    md_accum = prompt + md_accum
    md_accum = generate_response(md_accum, model=model, web_search=False)

    OUTPUT_MD.write_text(md_accum, encoding="utf-8")
    print(f"Wrote markdown to {OUTPUT_MD} ({len(md_accum)} chars)")

    # 呼叫 genRb（會嘗試使用 GEMINI_KEY）
    try:
        while genRb(md_accum, debug=enable_debug, FirstTry=True, prompt_index=prompt_index, model=model):
            print("Retrying generation...")
    except Exception as e:
        print("Generation failed:", e)
