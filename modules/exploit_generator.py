# modules/exploit_generator.py
from pathlib import Path
import os
import re
from typing import Optional
from .fetch_html import fetch_html
from .html2md import html_to_markdown
from config import NEXT_URL_TXT, OUTPUT_HTML, OUTPUT_MD, EXPLOIT_PATH, MAXIMUM_URLS, INITPROMPT, RETRYPROMPT, ERRORMSG

# 如果你使用 Gemini API：會嘗試使用 google.generativeai
# 若未設定 GEMINI_KEY，程式會提醒並不呼叫 API（保守行為）
def extract_code_best_effort(text: str) -> Optional[str]:
    # 優先找 ```ruby code fence
    m = re.findall(r"```ruby\s*(.*?)```", text, re.IGNORECASE | re.DOTALL)
    if m:
        return max(m, key=len).strip()
    # 找任意 code fence
    m_all = re.findall(r"```(?:[^\n]*)\n(.*?)```", text, re.DOTALL)
    if m_all:
        return max(m_all, key=len).strip()
    # fallback：找 MetasploitModule class 開頭
    m = re.search(r"(class\s+MetasploitModule\b.*)", text, re.DOTALL)
    if m:
        return m.group(1).strip()
    return None

def genRb(markdown_content: str, debug: bool = False, FirstTry: bool = True, prompt_index: int = 0) -> bool:
    """
    呼叫 LLM 生成 Ruby 程式（示意）。你需要設定環境變數 GEMINI_KEY
    若沒有 GEMINI_KEY，會 raise ValueError。
    返回 True 表示需要 retry（原 genRb 用法），False 表示完成或不再 retry。
    """
    GEMINI_API_KEY = os.getenv("GEMINI_KEY")
    if not GEMINI_API_KEY:
        raise ValueError("Please set GEMINI_KEY environment variable to use gemini generation")

    # 下面以 google.generativeai 為例（與你原本的類似）
    try:
        import google.generativeai as genai
    except Exception as e:
        raise RuntimeError("google.generativeai package is required for genRb: " + str(e))

    genai.configure(api_key=GEMINI_API_KEY)
    model = genai.GenerativeModel("gemini-2.0-flash")

    prompt = ""
    if FirstTry:
        # 從當前目錄取 InitPrompt.txt（如存在）
        init_prompt_path = INITPROMPT
        if init_prompt_path.exists():
            lines = init_prompt_path.read_text(encoding="utf-8").splitlines()
            # pick 一行（1-based index）
            if prompt_index > 0 and prompt_index <= len(lines):
                prompt = lines[prompt_index - 1]
            else:
                prompt = lines[0] if lines else ""
        else:
            prompt = ""
    else:
        # retry mode: 可從 exploit file 與 errorMsg.txt 組 prompt
        if EXPLOIT_PATH.exists():
            existing_code = EXPLOIT_PATH.read_text(encoding="utf-8")
        else:
            existing_code = ""
        error_msg_path = ERRORMSG
        err = error_msg_path.read_text(encoding="utf-8") if error_msg_path.exists() else ""
        retry_prompt_path = RETRYPROMPT
        retry_text = retry_prompt_path.read_text(encoding="utf-8").splitlines()[prompt_index - 1] if retry_prompt_path.exists() else ""
        prompt = existing_code + "\n Error msg: " + err + "\n" + retry_text

    prompt += "\n\n" + markdown_content
    # 呼叫 model
    response = model.generate_content(prompt)
    ruby_code = response.text

    # 若第一字不是 h（你原本有一個 check），此處保留舊邏輯：但不強依賴
    # 嘗試解析可能的 next urls（line 開頭為 http...）
    pattern = r'^(https?://[^\s\'"<>)]+(?:\s+https?://[^\s\'"<>)]+)*)'
    match = re.match(pattern, ruby_code)
    if match:
        next_url = match.group(1).split()
        with NEXT_URL_TXT.open("w", encoding="utf-8") as f:
            f.write("\n".join(next_url) + "\n")
        if debug:
            print("Wrote next urls from model response to", NEXT_URL_TXT)

    if debug:
        print("=== Gemini Response (truncated) ===")
        print(ruby_code[:1000])
        print("===================================")

    extracted = extract_code_best_effort(ruby_code)
    EXPLOIT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with EXPLOIT_PATH.open("w", encoding="utf-8") as f:
        if extracted:
            f.write(extracted)
            if debug:
                print(f"[+] Exploit generated and saved to: {EXPLOIT_PATH}")
        else:
            f.write(ruby_code)
            if debug:
                print(f"[!] Could not extract code cleanly, saved raw response to {EXPLOIT_PATH}")
    return False

def exec_genrb_from_main(retry: bool = False, enable_debug: bool = False, prompt_index: int = 1):
    """
    將 next_url.txt 裡的 url 抓下 html -> md -> 呼叫 genRb。
    這個函式供 main.py 呼叫（簡單封裝）。
    """
    # 讀 next_url.txt
    if not NEXT_URL_TXT.exists():
        print("No next_url.txt found at", NEXT_URL_TXT)
        return

    urls = [line.strip() for line in NEXT_URL_TXT.read_text(encoding="utf-8").splitlines() if line.strip()]
    if not urls:
        print("No urls in", NEXT_URL_TXT)
        return

    md_accum = ""
    t = 0
    for url in urls:
        if t >= MAXIMUM_URLS:
            break
        if not (url.startswith("http://") or url.startswith("https://")):
            print("Skipping invalid URL:", url)
            continue
        html = fetch_html(url, OUTPUT_HTML, debug=enable_debug)
        if not html:
            print("Skipping URL due to fetch error:", url)
            continue
        md_accum += f"Target url {url}:\n\n" + html_to_markdown(html) + "\n\n"
        t += 1

    OUTPUT_MD.write_text(md_accum, encoding="utf-8")
    print(f"Wrote markdown to {OUTPUT_MD} ({len(md_accum)} chars)")

    # 呼叫 genRb（會嘗試使用 GEMINI_KEY）
    try:
        while genRb(md_accum, debug=enable_debug, FirstTry=True, prompt_index=prompt_index):
            print("Retrying generation...")
    except Exception as e:
        print("Generation failed:", e)
